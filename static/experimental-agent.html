<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agent</title>
  <link rel="stylesheet" href="/static/styles.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    /* Agent-specific overrides to match the shell look */
    body {
      background-color: var(--bg-color);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .agent-layout {
      display: grid;
      grid-template-columns: 1fr 320px;
      height: 100%;
      max-width: 1600px;
      margin: 0 auto;
      width: 100%;
    }

    @media (max-width: 900px) {
      .agent-layout {
        grid-template-columns: 1fr;
      }

      .sidebar {
        display: none;
      }
    }

    /* Main Chat Area */
    .chat-panel {
      display: flex;
      flex-direction: column;
      height: 100%;
      min-height: 0;
      /* Critical for flex scrolling */
      overflow: hidden;
      position: relative;
      background: var(--bg-color);
    }

    .chat-header {
      padding: 16px 24px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-color);
      z-index: 10;
    }

    .model-selector {
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: var(--input-bg);
      color: var(--text-color);
      font-size: 0.9rem;
      cursor: pointer;
      min-width: 200px;
    }

    .chat-messages {
      flex: 1;
      min-height: 0;
      /* Critical for flex scrolling */
      overflow-y: auto;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .message {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-width: 85%;
      animation: fadeIn 0.2s ease-out;
    }

    .message.user {
      align-self: flex-end;
      align-items: flex-end;
      max-width: 70%;
      margin-left: auto;
    }

    .message.assistant {
      align-self: flex-start;
    }

    .message.system {
      align-self: center;
      max-width: 100%;
      background: var(--info-bg);
      padding: 8px 16px;
      border-radius: 99px;
      font-size: 0.85rem;
      color: var(--info-text);
    }

    .bubble {
      padding: 12px 18px;
      border-radius: 12px;
      font-size: 0.95rem;
      line-height: 1.5;
      position: relative;
    }

    .message.user .bubble {
      background: var(--button-bg);
      color: var(--button-text);
      border-bottom-right-radius: 2px;
    }

    .message.assistant .bubble {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      color: var(--text-color);
      border-bottom-left-radius: 2px;
    }

    /* Removed message-meta styles */

    /* Input Area */
    .input-container {
      flex-shrink: 0;
      padding: 16px 24px 24px;
      background: var(--bg-color);
    }

    .input-box {
      display: flex;
      align-items: center;
      gap: 8px;
      background: var(--input-bg);
      border: 1px solid var(--border-color);
      border-radius: 24px;
      padding: 8px 12px;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .input-box:focus-within {
      border-color: var(--text-color);
      box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
    }

    .input-field {
      flex: 1;
      border: none;
      background: transparent;
      padding: 8px 4px;
      font-size: 0.95rem;
      color: var(--text-color);
      outline: none;
    }

    .icon-btn {
      background: none;
      border: none;
      padding: 8px;
      cursor: pointer;
      color: var(--info-text);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background 0.15s, color 0.15s;
    }

    .icon-btn:hover {
      background: var(--info-bg);
      color: var(--text-color);
    }

    .icon-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .icon-btn.send {
      background: var(--button-bg);
      color: var(--button-text);
    }

    .icon-btn.send:hover {
      opacity: 0.9;
    }

    .icon-btn.send:disabled {
      opacity: 0.4;
    }

    /* Sidebar (Stack Trace) */
    .sidebar {
      border-left: 1px solid var(--border-color);
      background: var(--bg-color);
      display: flex;
      flex-direction: column;
      height: 100%;
      position: relative;
    }

    .sidebar-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-color);
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--text-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--card-bg);
    }

    .step-count {
      background: var(--button-bg);
      color: var(--button-text);
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .trace-list {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .trace-item {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
      transition: all 0.15s;
    }

    .trace-item:hover {
      border-color: var(--text-color);
    }

    .trace-header {
      padding: 12px 14px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      user-select: none;
    }

    .trace-header:hover {
      background: var(--info-bg);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .status-dot.running {
      background: #f59e0b;
      animation: pulse 1s infinite;
    }

    .status-dot.done {
      background: #10b981;
    }

    .status-dot.error {
      background: #ef4444;
    }

    .status-dot.pending {
      background: var(--border-color);
    }

    .trace-title {
      flex: 1;
      font-size: 0.8rem;
      font-weight: 500;
      color: var(--text-color);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .trace-time {
      font-size: 0.7rem;
      color: var(--info-text);
      font-weight: 500;
    }

    .trace-details {
      display: none;
      padding: 0 14px 14px;
      border-top: 1px solid var(--border-color);
    }

    .trace-item.expanded .trace-details {
      display: block;
    }

    .code-block {
      font-family: 'SF Mono', Monaco, 'Cascadia Code', Consolas, monospace;
      font-size: 0.75rem;
      line-height: 1.4;
      background: var(--info-bg);
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      overflow-x: auto;
      max-height: 150px;
      overflow-y: auto;
      margin-top: 6px;
      color: var(--text-color);
      white-space: pre-wrap;
      word-break: break-word;
    }

    .label {
      font-size: 0.65rem;
      text-transform: uppercase;
      color: var(--info-text);
      font-weight: 600;
      margin: 12px 0 4px 0;
      display: block;
      letter-spacing: 0.5px;
    }

    .label:first-child {
      margin-top: 12px;
    }

    @keyframes pulse {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }

      100% {
        opacity: 1;
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(5px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Markdown Styles */
    .prose p {
      margin-bottom: 0.5em;
    }

    .prose p:last-child {
      margin-bottom: 0;
    }

    .prose a {
      color: inherit;
      text-decoration: underline;
    }

    .prose ul,
    .prose ol {
      margin: 0.5em 0;
      padding-left: 1.2em;
    }

    .prose code {
      background: rgba(0, 0, 0, 0.1);
      padding: 2px 4px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.9em;
    }

    /* Markdown Styles & Tables */
    .prose table {
      width: 100%;
      border-collapse: collapse;
      margin: 1em 0;
      font-size: 0.9em;
    }

    .prose th,
    .prose td {
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      text-align: left;
    }

    .prose th {
      background: var(--input-bg);
      font-weight: 600;
    }

    .prose tr:nth-child(even) {
      background: rgba(0, 0, 0, 0.02);
    }

    .message.user .prose code {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Model reference badges */
    .model-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: #e8f4fd;
      border: 1px solid #b3d9f7;
      color: #1a73e8;
      padding: 3px 10px;
      border-radius: 16px;
      font-size: 0.85em;
      font-weight: 500;
      cursor: pointer;
      position: relative;
      transition: all 0.15s ease;
    }

    .model-badge:hover {
      background: #d0e8fc;
      border-color: #1a73e8;
    }

    /* Rich tooltip on hover */
    .model-tooltip {
      display: none;
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 16px;
      min-width: 260px;
      max-width: 320px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
      z-index: 200;
      text-align: left;
      color: var(--text-color);
      pointer-events: none;
    }

    .model-badge:hover .model-tooltip {
      display: block;
      animation: tooltipFade 0.15s ease-out;
    }

    @keyframes tooltipFade {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(4px);
      }

      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    .tooltip-header {
      margin-bottom: 12px;
    }

    .tooltip-header strong {
      font-size: 1rem;
    }

    .tooltip-provider {
      color: var(--info-text);
      font-size: 0.85rem;
    }

    .tooltip-section {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 4px;
      padding: 8px 0;
      border-top: 1px solid var(--border-color);
    }

    .tooltip-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      color: var(--info-text);
      font-weight: 600;
      width: 100%;
    }

    .tooltip-value {
      font-size: 0.9rem;
      font-weight: 500;
      color: #1a73e8;
    }

    .tooltip-evals {
      background: var(--info-bg);
      padding: 8px 10px;
      border-radius: 8px;
      margin-top: 8px;
      font-size: 0.8rem;
      color: var(--info-text);
    }

    /* Model carousel */
    .model-carousel {
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid var(--border-color);
    }

    .carousel-title {
      font-size: 1rem;
      font-weight: 600;
      margin: 0 0 12px 0;
      color: var(--text-color);
    }

    .carousel-container {
      display: flex;
      align-items: center;
      gap: 12px;
      position: relative;
    }

    .carousel-scroll {
      display: flex;
      gap: 16px;
      overflow-x: auto;
      scroll-behavior: smooth;
      scrollbar-width: none;
      -ms-overflow-style: none;
      padding: 4px 0;
      flex: 1;
    }

    .carousel-scroll::-webkit-scrollbar {
      display: none;
    }

    .carousel-btn {
      flex-shrink: 0;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1px solid var(--border-color);
      background: var(--card-bg);
      color: var(--text-color);
      font-size: 1.4rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .carousel-btn:hover {
      background: var(--info-bg);
      border-color: var(--text-color);
    }

    .carousel-dots {
      display: flex;
      justify-content: center;
      gap: 6px;
      margin-top: 12px;
    }

    .carousel-dots .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--border-color);
    }

    .carousel-dots .dot.active {
      background: #1a73e8;
    }

    /* Model cards */
    .model-card {
      flex: 0 0 200px;
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 16px;
      transition: box-shadow 0.2s ease;
    }

    .model-card:hover {
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    }

    .card-header {
      font-size: 0.95rem;
      margin-bottom: 4px;
    }

    .card-icon {
      font-size: 1rem;
    }

    .card-provider {
      font-size: 0.8rem;
      color: var(--info-text);
      margin-bottom: 12px;
    }

    .card-stat {
      margin-bottom: 8px;
    }

    .stat-label {
      display: block;
      font-size: 0.65rem;
      text-transform: uppercase;
      color: var(--info-text);
      font-weight: 600;
    }

    .stat-value {
      font-size: 0.9rem;
      font-weight: 600;
      color: #1a73e8;
    }

    .card-pricing {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: var(--text-color);
      margin-bottom: 12px;
    }

    .card-link {
      display: block;
      font-size: 0.8rem;
      color: #1a73e8;
      text-decoration: none;
    }

    .card-link:hover {
      text-decoration: underline;
    }

    /* Modal Styles */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.4);
      z-index: 100;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 24px;
      min-width: 320px;
      max-width: 400px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
    }

    .modal h3 {
      margin: 0 0 16px 0;
      font-size: 1rem;
      font-weight: 600;
    }

    .modal select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--input-bg);
      color: var(--text-color);
      font-size: 0.9rem;
      margin-bottom: 16px;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .modal-btn {
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.85rem;
      cursor: pointer;
      border: 1px solid var(--border-color);
      background: var(--bg-color);
      color: var(--text-color);
    }

    .modal-btn.primary {
      background: var(--button-bg);
      color: var(--button-text);
      border: none;
    }
  </style>
</head>

<body>
  <div class="agent-layout">
    <!-- Chat Area -->
    <div class="chat-panel">
      <div class="chat-header">
        <span style="font-weight: 600; font-size: 0.95rem;">AI Agent</span>
        <button id="settingsBtn" class="icon-btn" title="Settings">
          <i data-lucide="settings" style="width:18px; height:18px;"></i>
        </button>
      </div>

      <div id="messages" class="chat-messages">
        <div class="message system">
          Ask me about AI models, benchmarks, pricing, or news.
        </div>
      </div>

      <div class="input-container">
        <form id="chatForm" class="input-box">
          <button type="button" id="attachBtn" class="icon-btn" title="Attach image">
            <i data-lucide="paperclip" style="width:18px; height:18px;"></i>
          </button>
          <input type="text" id="questionInput" class="input-field"
            placeholder="Ask about AI models, benchmarks, or news..." autocomplete="off">
          <button type="submit" id="submitBtn" class="icon-btn send" title="Send">
            <i data-lucide="send" style="width:18px; height:18px;"></i>
          </button>
        </form>
        <input type="file" id="fileInput" accept="image/*" style="display:none;">
      </div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar">
      <span id="stepCount" class="step-count" style="position:absolute; top:12px; right:12px; z-index:10;">0</span>
      <div id="activityLog" class="trace-list" style="padding-top:8px;">
        <div style="text-align:center; color:var(--info-text); font-size:0.85rem; margin-top:20px;">
          Ready to start
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal-overlay">
    <div class="modal">
      <h3>Settings</h3>
      <label style="display:block; font-size:0.8rem; color:var(--info-text); margin-bottom:6px;">Model</label>
      <select id="modelSelect">
        <option value="x-ai/grok-4-fast">Loading models...</option>
      </select>

      <label style="display:flex; align-items:center; gap:8px; margin-top:12px; font-size:0.85rem; cursor:pointer;">
        <input type="checkbox" id="deeperModeToggle" style="width:16px; height:16px;">
        <span>Deeper Mode</span>
      </label>
      <p style="font-size:0.75rem; color:var(--info-text); margin:4px 0 12px 24px;">
        Agent will research more before responding
      </p>

      <div class="modal-actions">
        <button type="button" class="modal-btn" id="modalClose">Cancel</button>
        <button type="button" class="modal-btn primary" id="modalSave">Save</button>
      </div>
    </div>
  </div>

  <script>
    // Initialize Lucide icons
    document.addEventListener('DOMContentLoaded', () => {
      if (typeof lucide !== 'undefined') {
        lucide.createIcons();
      }
    });

    // Theme handling
    function syncTheme() {
      try {
        const parentTheme = window.parent.document.documentElement.getAttribute('data-theme');
        if (parentTheme) {
          document.documentElement.setAttribute('data-theme', parentTheme);
        }
      } catch (e) {
        // Fallback if not in iframe or cross-origin
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.setAttribute('data-theme', 'dark');
        }
      }
    }
    syncTheme();
    // Listen for theme changes if possible
    window.addEventListener('message', (event) => {
      if (event.data && event.data.type === 'theme-change') {
        document.documentElement.setAttribute('data-theme', event.data.theme);
      }
    });

    // App Logic
    const USER_KEY = 'dashboard-user-openrouter-key';
    const MODEL_KEY = 'dashboard-agent-exp-model';
    const MODELS_KEY = 'dashboard-available-models';

    const messagesEl = document.getElementById('messages');
    const form = document.getElementById('chatForm');
    const input = document.getElementById('questionInput');
    const submitBtn = document.getElementById('submitBtn');
    const modelSelect = document.getElementById('modelSelect');
    const activityLog = document.getElementById('activityLog');
    const stepCount = document.getElementById('stepCount');
    const settingsBtn = document.getElementById('settingsBtn');
    const attachBtn = document.getElementById('attachBtn');
    const fileInput = document.getElementById('fileInput');

    let pendingImage = null; // For image attachments
    let traceHistory = []; // Store traces per message: [{msgIndex, traces}]
    let currentMsgIndex = 0; // Track which message's trace is displayed
    const settingsModal = document.getElementById('settingsModal');
    const modalClose = document.getElementById('modalClose');
    const modalSave = document.getElementById('modalSave');
    const deeperModeToggle = document.getElementById('deeperModeToggle');
    const DEEPER_MODE_KEY = 'dashboard-agent-deeper-mode';

    // Load deeper mode setting
    deeperModeToggle.checked = localStorage.getItem(DEEPER_MODE_KEY) === 'true';

    // Settings button - open modal
    settingsBtn.addEventListener('click', () => {
      deeperModeToggle.checked = localStorage.getItem(DEEPER_MODE_KEY) === 'true';
      settingsModal.classList.add('active');
    });

    // Modal close
    modalClose.addEventListener('click', () => {
      settingsModal.classList.remove('active');
    });

    // Modal save
    modalSave.addEventListener('click', () => {
      localStorage.setItem(MODEL_KEY, modelSelect.value);
      localStorage.setItem(DEEPER_MODE_KEY, deeperModeToggle.checked);
      const modeNote = deeperModeToggle.checked ? ' (Deeper Mode ON)' : '';
      addMessage('system', `Settings saved${modeNote}`);
      settingsModal.classList.remove('active');
    });

    // Close modal on overlay click
    settingsModal.addEventListener('click', (e) => {
      if (e.target === settingsModal) {
        settingsModal.classList.remove('active');
      }
    });

    // Attachment button
    attachBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = () => {
          pendingImage = reader.result;
          addMessage('system', `ðŸ“Ž Image attached: ${file.name}`);
        };
        reader.readAsDataURL(file);
      }
      fileInput.value = ''; // Reset for next selection
    });

    let toolSteps = [];
    let conversationHistory = []; // Track full conversation for context

    function getApiKey() {
      return (localStorage.getItem(USER_KEY) || '').trim();
    }

    function formatTime(d) {
      // Show elapsed seconds since first tool step
      if (toolSteps.length > 0 && toolSteps[0].time) {
        const elapsed = Math.round((d - toolSteps[0].time) / 1000);
        return `${elapsed}s`;
      }
      return '0s';
    }

    async function loadModels() {
      const stored = localStorage.getItem(MODELS_KEY) || '';
      let models = stored ? stored.split(',').map(s => s.trim()).filter(Boolean) : [];

      if (!models.length) {
        try {
          const res = await fetch('/api/model-config');
          if (res.ok) {
            const cfg = await res.json();
            models = (cfg.agent && cfg.agent.availableModels) || [];
          }
        } catch (_) { }
      }

      if (!models.length) {
        models = ['x-ai/grok-4-fast', 'anthropic/claude-sonnet-4', 'openai/gpt-4.1', 'google/gemini-2.5-flash'];
      }

      modelSelect.innerHTML = models.map(id =>
        `<option value="${id}">${id.split('/').pop()}</option>`
      ).join('');

      const saved = localStorage.getItem(MODEL_KEY);
      if (saved && models.includes(saved)) modelSelect.value = saved;
    }

    modelSelect.addEventListener('change', () => {
      localStorage.setItem(MODEL_KEY, modelSelect.value);
    });

    // Track collected model references for carousel
    let collectedModelRefs = [];
    let llmDataCache = null;

    // Multi-source model data cache
    let modelDataCache = {
      llms: null,
      'text-to-image': null,
      fal: null
    };

    // Fetch model data from a specific source
    async function fetchModelData(source) {
      if (modelDataCache[source]) return modelDataCache[source];

      const apiMap = {
        'llms': '/api/llms',
        'text-to-image': '/api/text-to-image',
        'image-editing': '/api/image-editing',
        'text-to-speech': '/api/text-to-speech',
        'text-to-video': '/api/text-to-video',
        'image-to-video': '/api/image-to-video',
        'fal': '/api/fal-models',
        'openrouter': '/api/openrouter-models'
      };

      const endpoint = apiMap[source];
      if (!endpoint) return [];

      try {
        const res = await fetch(endpoint);
        const data = await res.json();
        // Handle different response structures
        const models = data.data || data.models || data || [];
        modelDataCache[source] = Array.isArray(models) ? models : [];
        return modelDataCache[source];
      } catch (e) {
        console.error(`Failed to fetch ${source} data:`, e);
        return [];
      }
    }

    // Fetch LLM data (backwards compatible)
    async function fetchLLMData() {
      return fetchModelData('llms');
    }

    // Normalize string for fuzzy matching - remove special chars, lowercase
    function normalizeForMatch(str) {
      return (str || '').toLowerCase().replace(/[^a-z0-9]/g, '');
    }

    // Extract model name portion (after last /)
    function extractModelPart(search) {
      const parts = search.split('/');
      return parts[parts.length - 1];
    }

    // Client-side cache for API lookup results
    const apiLookupCache = {};

    // Find model in data by name, slug, or ID - with fuzzy matching + LLM API fallback
    async function findModelData(modelName, sourceHint) {
      // First, try local fuzzy match (fast path)
      const localMatch = findModelDataLocal(modelName, sourceHint);
      if (localMatch) return localMatch;

      // If no local match, try LLM-based API lookup
      const cacheKey = `${sourceHint || 'all'}::${modelName.toLowerCase()}`;
      if (apiLookupCache[cacheKey]) {
        return apiLookupCache[cacheKey];
      }

      // Call the model-card-lookup API
      if (sourceHint) {
        try {
          const response = await fetch('/api/model-card-lookup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ source: sourceHint, name: modelName })
          });
          if (response.ok) {
            const result = await response.json();
            if (result.match && result.match.metadata) {
              apiLookupCache[cacheKey] = result.match.metadata;
              // Also add to local cache for future lookups
              if (modelDataCache[sourceHint]) {
                modelDataCache[sourceHint].push(result.match.metadata);
              }
              return result.match.metadata;
            }
          }
        } catch (e) {
          console.warn('Model card lookup API failed:', e);
        }
      }

      apiLookupCache[cacheKey] = null;
      return null;
    }

    // Local-only fuzzy match (synchronous)
    function findModelDataLocal(modelName, sourceHint) {
      const searchNorm = normalizeForMatch(modelName);
      const searchLower = modelName.toLowerCase();
      const modelPart = extractModelPart(modelName);
      const modelPartNorm = normalizeForMatch(modelPart);

      const sources = sourceHint ? [sourceHint] : Object.keys(modelDataCache);

      for (const source of sources) {
        const cache = modelDataCache[source];
        if (!cache) continue;

        const found = cache.find(m => {
          const name = (m.name || '').toLowerCase();
          const title = (m.title || '').toLowerCase();
          const slug = (m.slug || '').toLowerCase();
          const id = (m.id || '').toLowerCase();

          if (name && (name === searchLower || name.includes(searchLower) || searchLower.includes(name))) return true;
          if (title && (title === searchLower || title.includes(searchLower) || searchLower.includes(title))) return true;
          if (slug && (slug === searchLower || slug.includes(searchLower) || searchLower.includes(slug))) return true;
          if (id && (id === searchLower || id.includes(searchLower) || searchLower.includes(id))) return true;

          const nameNorm = normalizeForMatch(m.name);
          const titleNorm = normalizeForMatch(m.title);
          const slugNorm = normalizeForMatch(m.slug);

          if (searchNorm && nameNorm && (nameNorm.includes(searchNorm) || searchNorm.includes(nameNorm))) return true;
          if (searchNorm && titleNorm && (titleNorm.includes(searchNorm) || searchNorm.includes(titleNorm))) return true;
          if (searchNorm && slugNorm && (slugNorm.includes(searchNorm) || searchNorm.includes(slugNorm))) return true;

          if (modelPartNorm && nameNorm && (nameNorm.includes(modelPartNorm) || modelPartNorm.includes(nameNorm))) return true;
          if (modelPartNorm && titleNorm && (titleNorm.includes(modelPartNorm) || modelPartNorm.includes(titleNorm))) return true;
          if (modelPartNorm && slugNorm && (slugNorm.includes(modelPartNorm) || modelPartNorm.includes(slugNorm))) return true;

          return false;
        });
        if (found) return found;
      }
      return null;
    }


    // Build tooltip HTML for a model (handles LLM, image gen, and fal models)
    function buildModelTooltip(model, source) {
      if (!model) return '';
      const name = model.name || model.title || 'Unknown';
      const provider = model.model_creator?.name || model.provider || source || 'Unknown';

      let html = `<div class="tooltip-header"><strong>${escapeHtml(name)}</strong><br><span class="tooltip-provider">${escapeHtml(provider)}</span></div>`;

      // LLM specific fields
      const speed = model.median_output_tokens_per_second;
      if (speed) {
        html += `<div class="tooltip-section"><span class="tooltip-label">OUTPUT SPEED</span><span class="tooltip-value">${Math.round(speed).toLocaleString()} tokens/s</span></div>`;
      }

      // Image generation specific fields (text-to-image)
      if (model.elo) {
        html += `<div class="tooltip-section"><span class="tooltip-label">ELO SCORE</span><span class="tooltip-value">${model.elo}</span></div>`;
      }
      if (model.rank) {
        html += `<div class="tooltip-section"><span class="tooltip-label">RANK</span><span class="tooltip-value">#${model.rank}</span></div>`;
      }

      // Fal.ai specific fields
      if (model.category) {
        html += `<div class="tooltip-section"><span class="tooltip-label">CATEGORY</span><span class="tooltip-value">${model.category}</span></div>`;
      }
      if (model.description) {
        const shortDesc = model.description.slice(0, 100) + (model.description.length > 100 ? '...' : '');
        html += `<div class="tooltip-section"><span class="tooltip-label">DESCRIPTION</span><span class="tooltip-value" style="font-size:0.75rem">${escapeHtml(shortDesc)}</span></div>`;
      }

      // LLM pricing (structured)
      const pricing = model.pricing;
      if (pricing && typeof pricing === 'object' && (pricing.price_1m_input_tokens != null || pricing.price_1m_output_tokens != null)) {
        html += `<div class="tooltip-section"><span class="tooltip-label">COST</span>`;
        html += `<span class="tooltip-value">Input $${pricing.price_1m_input_tokens?.toFixed(2) || 'N/A'}</span>`;
        html += `<span class="tooltip-value">Output $${pricing.price_1m_output_tokens?.toFixed(2) || 'N/A'}</span></div>`;
      }
      // Fal pricing (string)
      if (pricing && typeof pricing === 'string' && pricing.trim()) {
        html += `<div class="tooltip-section"><span class="tooltip-label">PRICING</span><span class="tooltip-value" style="font-size:0.75rem">${escapeHtml(pricing)}</span></div>`;
      }

      // LLM evaluations
      const evals = model.evaluations || {};
      const evalItems = [];
      if (evals.artificial_analysis_coding_index) evalItems.push(`Coding: ${evals.artificial_analysis_coding_index.toFixed(1)}`);
      if (evals.artificial_analysis_intelligence_index) evalItems.push(`Intelligence: ${evals.artificial_analysis_intelligence_index.toFixed(1)}`);
      if (evals.artificial_analysis_math_index) evalItems.push(`Math: ${evals.artificial_analysis_math_index.toFixed(1)}`);

      if (evalItems.length) {
        html += `<div class="tooltip-evals">${evalItems.join('<br>')}</div>`;
      }

      return html;
    }

    // Build model card HTML for carousel (handles LLM, image gen, and fal models)
    function buildModelCard(model, source) {
      if (!model) return '';
      const name = model.name || model.title || 'Unknown';
      const prov = model.model_creator?.name || model.provider || source || 'Unknown';

      // Provider color
      const colors = { 'Google': '#4285f4', 'OpenAI': '#10a37f', 'Anthropic': '#d97706', 'Meta': '#1877f2', 'Mistral': '#ff7000', 'xAI': '#1d9bf0', 'Black Forest Labs': '#6366f1', 'ByteDance Seed': '#ef4444' };
      const accent = colors[prov] || '#6b7280';

      // Build stats based on model type
      let statsHtml = '';

      // LLM stats
      const speed = model.median_output_tokens_per_second;
      if (speed) {
        statsHtml += `<div class="card-stat"><span class="stat-label">OUTPUT SPEED</span><span class="stat-value">${Math.round(speed).toLocaleString()} tokens/s</span></div>`;
      }

      // Image gen stats
      if (model.elo) {
        statsHtml += `<div class="card-stat"><span class="stat-label">ELO</span><span class="stat-value">${model.elo}</span></div>`;
      }
      if (model.rank) {
        statsHtml += `<div class="card-stat"><span class="stat-label">RANK</span><span class="stat-value">#${model.rank}</span></div>`;
      }

      // Fal stats
      if (model.category) {
        statsHtml += `<div class="card-stat"><span class="stat-label">CATEGORY</span><span class="stat-value">${model.category}</span></div>`;
      }

      // LLM pricing
      const pricing = model.pricing;
      let pricingHtml = '';
      if (pricing && typeof pricing === 'object' && (pricing.price_1m_input_tokens != null || pricing.price_1m_output_tokens != null)) {
        pricingHtml = `<div class="card-pricing">
          <span>Input <strong>$${pricing.price_1m_input_tokens?.toFixed(0) || 'N/A'}</strong></span>
          <span>Output <strong>$${pricing.price_1m_output_tokens?.toFixed(0) || 'N/A'}</strong></span>
        </div>`;
      }

      // Thumbnail for fal models
      let thumbnailHtml = '';
      if (model.thumbnailUrl) {
        thumbnailHtml = `<img src="${model.thumbnailUrl}" alt="${escapeHtml(name)}" style="width:100%;height:60px;object-fit:cover;border-radius:4px;margin-bottom:8px;">`;
      }

      // Construct model URL based on source
      let cardUrl = '#';
      const slug = model.slug || name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
      if (source === 'llms' || source === 'text-to-image' || source === 'text-to-video' || source === 'image-to-video') {
        cardUrl = `https://artificialanalysis.ai/models/${slug}`;
      } else if (source === 'fal') {
        cardUrl = `https://fal.ai/models/${model.id || slug}`;
      } else if (source === 'openrouter') {
        cardUrl = `https://openrouter.ai/models/${model.id || slug}`;
      }

      // Only show link if we have a valid URL
      const linkHtml = cardUrl !== '#'
        ? `<a class="card-link" href="${cardUrl}" target="_blank" rel="noopener">View Full Card</a>`
        : '';

      return `<div class="model-card" style="border-left: 4px solid ${accent}">
        ${thumbnailHtml}
        <div class="card-header"><span class="card-icon">ðŸ¤–</span> <strong>${escapeHtml(name)}</strong></div>
        <div class="card-provider">${escapeHtml(prov)}</div>
        ${statsHtml}
        ${pricingHtml}
        ${linkHtml}
      </div>`;
    }

    function renderMarkdown(content) {
      if (!content) return { html: '', refs: [] };

      const refs = [];
      let badgeId = 0;

      // Custom bracket-aware parser for [[model:source:name]] tags
      // Handles model names with brackets like FLUX.2 [max]
      function parseModelTags(text) {
        let result = '';
        let i = 0;
        while (i < text.length) {
          // Check for [[model: or [[models:
          if ((text.slice(i, i + 8) === '[[model:' || text.slice(i, i + 9) === '[[models:')) {
            const prefixLen = text.slice(i, i + 9) === '[[models:' ? 9 : 8;
            const innerStart = i + prefixLen;
            let j = innerStart;
            let bracketCount = 0;
            let found = false;

            // Scan forward, tracking nested brackets
            while (j < text.length) {
              if (text[j] === '[') {
                bracketCount++;
              } else if (text[j] === ']') {
                if (bracketCount > 0) {
                  bracketCount--;
                } else if (text[j + 1] === ']') {
                  // Found closing ]] while not inside nested brackets
                  const inner = text.slice(innerStart, j);
                  const colonIdx = inner.indexOf(':');

                  if (colonIdx !== -1) {
                    const source = inner.substring(0, colonIdx).trim();
                    const modelName = inner.substring(colonIdx + 1).trim();

                    if (source && modelName) {
                      refs.push({ source, name: modelName, id: `model-badge-${badgeId}` });
                      result += `<span class="model-badge" id="model-badge-${badgeId}" data-source="${escapeHtml(source)}" data-model-name="${escapeHtml(modelName)}">ðŸ¤– ${escapeHtml(modelName)}</span>`;
                      badgeId++;
                      i = j + 2; // Skip past ]]
                      found = true;
                      break;
                    }
                  }
                  // Invalid format, output as-is
                  result += text.slice(i, j + 2);
                  i = j + 2;
                  found = true;
                  break;
                }
              }
              j++;
            }

            if (!found) {
              // No closing ]] found, output character and continue
              result += text[i];
              i++;
            }
          } else {
            result += text[i];
            i++;
          }
        }
        return result;
      }

      let processed = parseModelTags(content);

      let html = '';
      if (typeof marked !== 'undefined' && typeof DOMPurify !== 'undefined') {
        html = DOMPurify.sanitize(marked.parse(processed));
      } else {
        html = processed;
      }

      return { html, refs };
    }

    // Chart rendering function - handles various code block formats
    function renderCharts(container) {
      // Look for JSON that looks like chart config in code blocks OR raw text
      const codeBlocks = container.querySelectorAll('pre, code');
      const seen = new Set();

      codeBlocks.forEach(block => {
        // Avoid processing same element twice
        if (seen.has(block)) return;
        seen.add(block);

        let text = block.textContent.trim();

        // Try to extract JSON - more flexible regex that works with or without labels
        const jsonMatch = text.match(/\{[\s\S]*"type"[\s\S]*"datasets"[\s\S]*\}/);
        if (!jsonMatch) return;

        try {
          const config = JSON.parse(jsonMatch[0]);
          if (!config.type || !config.datasets) return;

          // For non-scatter charts, labels are required
          if (config.type !== 'scatter' && !config.labels) return;

          // Create chart container with B&W aesthetic
          const chartContainer = document.createElement('div');
          chartContainer.className = 'chart-container';
          chartContainer.style.cssText = 'width: 100%; max-width: 600px; margin: 20px 0; padding: 20px; background: var(--card-bg); border-radius: 12px; border: 1px solid var(--border-color);';

          const canvas = document.createElement('canvas');
          canvas.id = 'chart-' + Date.now() + Math.random().toString(36).slice(2);
          chartContainer.appendChild(canvas);

          // Replace the code block element (or its parent pre)
          const toReplace = block.closest('pre') || block;
          toReplace.replaceWith(chartContainer);

          // Grayscale color palette for B&W aesthetic
          const grayscaleColors = [
            'rgba(0, 0, 0, 0.8)',
            'rgba(60, 60, 60, 0.8)',
            'rgba(100, 100, 100, 0.8)',
            'rgba(140, 140, 140, 0.8)',
            'rgba(180, 180, 180, 0.8)',
            'rgba(200, 200, 200, 0.8)'
          ];

          // Build chart options based on type
          const chartType = config.type;
          const isScatter = chartType === 'scatter';

          const chartData = {
            labels: config.labels || [],
            datasets: config.datasets.map((ds, i) => ({
              label: ds.label || `Dataset ${i + 1}`,
              data: ds.data,
              backgroundColor: ds.backgroundColor || grayscaleColors[i % grayscaleColors.length],
              borderColor: ds.borderColor || 'rgba(0, 0, 0, 0.3)',
              borderWidth: 1,
              pointRadius: isScatter ? 6 : undefined,
              pointHoverRadius: isScatter ? 8 : undefined
            }))
          };

          const chartOptions = {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: config.datasets.length > 1,
                labels: { color: 'rgb(100, 100, 100)', font: { family: 'Inter, system-ui, sans-serif' } }
              },
              tooltip: isScatter ? {
                callbacks: {
                  title: (ctxArr) => {
                    // Show name/label as title for better visibility
                    const point = ctxArr[0]?.raw;
                    return point?.name || point?.label || point?.title || '';
                  },
                  label: (ctx) => {
                    const point = ctx.raw;
                    const name = point.name || point.label || point.title || '';
                    const xLabel = config.options?.scales?.x?.title?.text || 'X';
                    const yLabel = config.options?.scales?.y?.title?.text || 'Y';
                    const lines = [];
                    if (name) lines.push(name);
                    lines.push(`${xLabel}: ${point.x}`);
                    lines.push(`${yLabel}: ${point.y}`);
                    return lines;
                  }
                }
              } : {}
            },
            scales: (chartType === 'bar' || chartType === 'line' || isScatter) ? {
              y: {
                beginAtZero: !isScatter,
                ticks: { color: 'rgb(100, 100, 100)' },
                grid: { color: 'rgba(0, 0, 0, 0.1)' },
                title: isScatter && config.options?.scales?.y?.title ? config.options.scales.y.title : undefined
              },
              x: {
                ticks: { color: 'rgb(100, 100, 100)' },
                grid: { color: 'rgba(0, 0, 0, 0.05)' },
                title: isScatter && config.options?.scales?.x?.title ? config.options.scales.x.title : undefined
              }
            } : {}
          };

          // Render chart
          new Chart(canvas.getContext('2d'), {
            type: chartType,
            data: chartData,
            options: chartOptions
          });

          console.log('Chart rendered successfully:', chartType);
        } catch (e) {
          console.log('Chart parse error:', e.message);
        }
      });
    }

    async function addMessage(role, content) {
      const msgIndex = traceHistory.length;
      const msg = document.createElement('div');
      msg.className = `message ${role}`;

      const bubble = document.createElement('div');
      bubble.className = 'bubble prose';

      // Check if content is raw JSON chart data (not wrapped in code blocks)
      // If so, wrap it so renderCharts can detect and render it
      let processedContent = content;
      if (role === 'assistant' && content) {
        const trimmed = content.trim();
        // Check if it looks like raw JSON chart data
        if (trimmed.startsWith('{') && trimmed.includes('"type"') && trimmed.includes('"datasets"')) {
          try {
            const parsed = JSON.parse(trimmed);
            if (parsed.type && parsed.datasets) {
              // It's chart JSON - wrap in code block for renderCharts
              processedContent = '```json\n' + trimmed + '\n```';
            }
          } catch (e) {
            // Not valid JSON, proceed normally
          }
        }
      }

      // Use new renderMarkdown that returns {html, refs}
      const result = renderMarkdown(processedContent);
      let htmlContent = typeof result === 'string' ? result : result.html;
      const refs = result.refs || [];

      bubble.innerHTML = htmlContent;

      // Make assistant messages clickable to show their trace
      if (role === 'assistant') {
        msg.style.cursor = 'pointer';
        msg.title = 'Click to view trace for this response';
        msg.addEventListener('click', () => showTraceForMessage(msgIndex));
        // Store current toolSteps for this message
        traceHistory.push({ msgIndex, traces: [...toolSteps] });

        // If we have model refs, fetch data from all unique sources
        if (refs.length > 0) {
          // Get unique sources referenced
          const uniqueSources = [...new Set(refs.map(r => r.source))];

          // Fetch data for all referenced sources
          await Promise.all(uniqueSources.map(src => fetchModelData(src)));

          // Build all cards first, then filter out empty ones (async)
          const cardPromises = refs.map(async ref => {
            const model = await findModelData(ref.name, ref.source);
            return buildModelCard(model, ref.source);
          });
          const cards = (await Promise.all(cardPromises)).filter(card => card && card.trim() !== '');

          if (cards.length > 0) {
            const carouselId = 'carousel-' + Date.now();

            // Build carousel with unique ID
            const carouselHtml = `<div class="model-carousel" id="${carouselId}">
              <h4 class="carousel-title">Model Cards</h4>
              <div class="carousel-container">
                <button class="carousel-btn prev" onclick="scrollCarouselById('${carouselId}', -1)">â€¹</button>
                <div class="carousel-scroll">
                  ${cards.join('')}
                </div>
                <button class="carousel-btn next" onclick="scrollCarouselById('${carouselId}', 1)">â€º</button>
              </div>
            </div>`;

            bubble.innerHTML += carouselHtml;
          } else {
            // No cards to display - carousel not added
          }

          // Attach tooltips to badges (async)
          await Promise.all(refs.map(async ref => {
            const badge = bubble.querySelector(`#${ref.id}`);
            if (badge) {
              const model = await findModelData(ref.name, ref.source);
              if (model) {
                const tooltip = document.createElement('div');
                tooltip.className = 'model-tooltip';
                tooltip.innerHTML = buildModelTooltip(model, ref.source);
                badge.appendChild(tooltip);
              }
            }
          }));
        } else {
          // No model refs found in content
        }
      }

      msg.appendChild(bubble);
      messagesEl.appendChild(msg);
      messagesEl.scrollTop = messagesEl.scrollHeight;

      // Try to render any charts in the message
      if (role === 'assistant') {
        setTimeout(() => renderCharts(bubble), 100);
      }
    }

    // Carousel scroll function using ID
    window.scrollCarouselById = function (carouselId, direction) {
      const carousel = document.getElementById(carouselId);
      if (!carousel) return;
      const track = carousel.querySelector('.carousel-scroll');
      if (!track) return;
      const cardWidth = track.querySelector('.model-card')?.offsetWidth || 220;
      track.scrollBy({ left: direction * (cardWidth + 16), behavior: 'smooth' });
    };

    function showTraceForMessage(msgIndex) {
      const entry = traceHistory.find(h => h.msgIndex === msgIndex);
      if (entry) {
        toolSteps = entry.traces;
        currentMsgIndex = msgIndex;
        renderActivityLog();
      }
    }

    function addToolStep(title, status = 'running', args = null, result = null) {
      const step = {
        id: Date.now() + Math.random(),
        title,
        status,
        args,
        result,
        time: new Date(),
        expanded: false
      };
      toolSteps.push(step);
      renderActivityLog();
      return step;
    }

    function updateToolStep(stepId, updates) {
      const step = toolSteps.find(s => s.id === stepId);
      if (step) {
        Object.assign(step, updates);
        renderActivityLog();
      }
    }

    function renderActivityLog() {
      stepCount.textContent = toolSteps.length;

      if (!toolSteps.length) {
        activityLog.innerHTML = '<div style="text-align:center; color:var(--info-text); font-size:0.85rem; margin-top:20px;">Ready to start</div>';
        return;
      }

      activityLog.innerHTML = toolSteps.map(step => `
        <div class="trace-item ${step.expanded ? 'expanded' : ''}">
          <div class="trace-header" onclick="toggleStep(${step.id})">
            <div class="status-dot ${step.status}"></div>
            <div class="trace-title" title="${escapeHtml(step.title)}">${escapeHtml(friendlyToolName(step.title))}</div>
            <div class="trace-time">${formatTime(step.time)}</div>
          </div>
          <div class="trace-details">
            ${step.args ? `
              <span class="label">Input</span>
              <div class="code-block">${formatArgs(step.args)}</div>
            ` : ''}
            ${step.result ? `
              <span class="label">Result</span>
              <div class="code-block">${formatResult(step.result)}</div>
            ` : ''}
            ${!step.args && !step.result ? '<span style="color:var(--info-text);margin-top:12px;display:block;">No details available</span>' : ''}
          </div>
        </div>
      `).join('');
    }

    window.toggleStep = function (id) {
      const step = toolSteps.find(s => s.id === id);
      if (step) {
        step.expanded = !step.expanded;
        renderActivityLog();
      }
    };

    // Format tool names to be more user-friendly
    function friendlyToolName(name) {
      const nameMap = {
        'fetch_llm_benchmarks': 'Checking LLM Leaderboards',
        'fetch_media_benchmarks': 'Checking Media Model Rankings',
        'fetch_openrouter_models': 'Fetching OpenRouter Catalog',
        'fetch_fal_models': 'Fetching Fal.ai Models',
        'fetch_replicate_models': 'Fetching Replicate Models',
        'search_models': 'Searching Models',
        'get_model_details': 'Getting Model Details',
        'Agent ready': 'Agent Ready',
        'Generating response': 'Generating Response',
        'Final response': 'Final Response'
      };
      return nameMap[name] || name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    }

    // Format arguments for display
    function formatArgs(args) {
      if (!args) return '';
      try {
        const str = typeof args === 'string' ? args : JSON.stringify(args, null, 2);
        return escapeHtml(str.length > 300 ? str.slice(0, 300) + '...' : str);
      } catch {
        return escapeHtml(String(args));
      }
    }

    // Format result for display - truncate long results
    function formatResult(result) {
      if (!result) return '';
      const str = typeof result === 'string' ? result : JSON.stringify(result, null, 2);
      const truncated = str.length > 400 ? str.slice(0, 400) + '\n... (truncated)' : str;
      return escapeHtml(truncated);
    }

    function escapeHtml(str) {
      if (!str) return '';
      return String(str).replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
    }

    form.addEventListener('submit', async (e) => {
      e.preventDefault();

      const question = input.value.trim();
      if (!question) return;

      const apiKey = getApiKey();
      if (!apiKey) {
        addMessage('system', 'âš ï¸ Please add your OpenRouter API key in the main dashboard settings.');
        return;
      }

      // Reset tool trace for this turn
      toolSteps = [];
      renderActivityLog();

      // Build user content (text + optional image)
      let userContent = question;
      const currentImage = pendingImage;
      if (currentImage) {
        // Show indicator that image is attached
        addMessage('user', `ðŸ“· [Image attached]\n\n${question}`);
        pendingImage = null; // Clear for next message
      } else {
        addMessage('user', question);
      }

      // Add user message to history
      conversationHistory.push({ role: 'user', content: question });
      input.value = '';
      submitBtn.disabled = true;

      const initStep = addToolStep('Initializing agent', 'running');

      try {
        const requestBody = {
          question: question,
          model: modelSelect.value,
          history: conversationHistory.slice(-10),
          deeper_mode: deeperModeToggle.checked
        };

        // Include image if attached
        if (currentImage) {
          requestBody.image = currentImage;
        }

        // Retry logic for transient 502 errors
        const maxRetries = 3;
        let lastError = null;
        let response = null;

        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 120000);

            response = await fetch('/api/experimental-agent', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
              },
              body: JSON.stringify(requestBody),
              signal: controller.signal,
              cache: 'no-store'
            });

            clearTimeout(timeoutId);

            // Check for 502 specifically and retry
            if (response.status === 502 && attempt < maxRetries - 1) {
              const delay = Math.pow(2, attempt + 1) * 1000; // 2s, 4s, 8s
              console.log(`Got 502, retrying in ${delay / 1000}s (attempt ${attempt + 1}/${maxRetries})`);
              updateToolStep(initStep.id, { title: `Retrying... (attempt ${attempt + 2})` });
              await new Promise(r => setTimeout(r, delay));
              continue;
            }

            break; // Success or non-502 error
          } catch (e) {
            lastError = e;
            if (attempt < maxRetries - 1 && e.name !== 'AbortError') {
              const delay = Math.pow(2, attempt + 1) * 1000;
              console.log(`Request failed, retrying in ${delay / 1000}s`);
              await new Promise(r => setTimeout(r, delay));
              continue;
            }
            throw e;
          }
        }

        const contentType = response.headers.get('content-type') || '';
        if (contentType.includes('text/html')) {
          throw new Error(`Server returned HTML (status ${response.status}). Service may be restarting.`);
        }

        const data = await response.json();

        if (data.error) {
          throw new Error(data.error);
        }

        updateToolStep(initStep.id, { status: 'done', title: 'Agent ready' });

        // Show tool calls
        if (data.tool_calls && data.tool_calls.length) {
          data.tool_calls.forEach(tc => {
            addToolStep(
              tc.tool,
              tc.status || 'done',
              tc.args,
              tc.result
            );
          });
        }

        addToolStep('Final response', 'done');

        if (data.response) {
          // Add assistant response to history
          conversationHistory.push({ role: 'assistant', content: data.response });
          addMessage('assistant', data.response);
        } else {
          addMessage('system', 'Agent returned no response.');
        }

      } catch (error) {
        console.error('Agent error:', error);
        updateToolStep(initStep.id, { status: 'error', title: 'Error: ' + error.message });
        addMessage('system', `Error: ${error.message}`);
      } finally {
        submitBtn.disabled = false;
        input.focus();
      }
    });

    loadModels();
    if (!getApiKey()) {
      addMessage('system', 'âš ï¸ Please add your OpenRouter API key in the main dashboard settings.');
    }
  </script>
</body>

</html>